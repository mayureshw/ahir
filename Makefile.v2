# Pending binaries
# formatVhdlFiles.py
# ghdlSanitize.sh

# LIBS are .a, not to be installed, consumed for build (to be confirmed)
# .so exist, but have to confirm whether they are to be installed

# Dependencies: boost, antlr2, llvm

CXX		=	/usr/pkg/gcc12/bin/c++
CXXFLAGS+=  -I/usr/pkg/include -MMD -MP
ANTLR	=	antlr
AR		=	ar
ARFLAGS	=	rcs
#RANLIB	=	ranlib

PROJECTS	=	AHIRASM HIERSYS LIBAHIR LLVM2AA BITVECS VALUE FNLIB IOLIB VERSION CTESTBENCH BGLWRAP

AHIRASM_DIR	=	Ahir-asm/devel
AHIRASM_BINS=	Aa2C Aa2VC AaLinkExtMem AaOpt AaPreprocess
AHIRASM_LIBS=	Aa
AHIRASM_GRAM=	Aa

HIERSYS_DIR	=	HierSysBuild
HIERSYS_BINS=	hierSys2C hierSys2Vhdl hierSysCheck hierSysGenVhdlComponentsPackage hierSysPartition hierSysUniquify
HIERSYS_LIBS=	HierSys
HIERSYS_GRAM=	hierSys

LIBAHIR_DIR	=	libAhirV2
LIBAHIR_BINS=	vc2vhdl vcAnalyze vcFormat vcParse vhdlFormat
LIBAHIR_LIBS=	VC
LIBAHIR_GRAM=	vc
vcParse_SRC=	vcParseMain

LLVM2AA_DIR	=	llvmbc2Aa
LLVM2AA_BINS=	llvm2aa

BITVECS_DIR	=	BitVectors
BITVECS_LIBS=	BitVectors

VALUE_DIR	=	Value
VALUE_LIBS	=	Value

FNLIB_DIR	=	functionLibrary
FNLIB_LIBS	=	fpu llvm_intrinsics timer

IOLIB_DIR	=	iolib
IOLIB_LIBS	=	io

VERSION_DIR	=	version
VERSION_LIBS=	AhirVersion

CTESTBENCH_DIR=	CtestBench

BGLWRAP_DIR=	BGLWrap


# # # # # Usually no change should be required below this point # # # # #

BINS	=	$(foreach p,$(PROJECTS), $(addprefix $($(p)_DIR)/bin/, $($(p)_BINS)))
LIBS	=	$(foreach p,$(PROJECTS), $(addsuffix .a,$(addprefix $($(p)_DIR)/lib/lib, $($(p)_LIBS))))
INCDIRS	=	$(foreach p,$(PROJECTS), $($(p)_DIR)/include) $(foreach p,$(PROJECTS),$(foreach g,$(p)_GRAM,$($(p)_DIR)/src))
CXXFLAGS+=	$(addprefix -I,$(INCDIRS))

%.o:	%.cpp
	$(CXX) $(CXXFLAGS) -c $< -o $@

%.o:	%.c
	$(CC) $(CXXFLAGS) -c $< -o $@

define f_ANTLROPS
$(addprefix $($(1)_DIR)/src/, $(foreach g,$($(1)_GRAM), $(foreach suf,Lexer Parser, $(foreach ext,.hpp .cpp, $(g)$(suf)$(ext)))))
endef

define f_ANTLRINP
$(foreach g,$($(1)_GRAM),$($(1)_DIR)/grammar/$(g).g)
endef

define f_LIBSRCS
$(if $(filter-out 1,$(words $($(1)_LIBS))),\
	$($(1)_DIR)/src/$(2).c,\
	$(sort $(wildcard $($(1)_DIR)/src/*.cpp) $(filter %.cpp,$(call f_ANTLROPS,$(1)))))
endef

define f_SRC2O
$(subst .c,.o,$(subst .cpp,.o,$(1)))
endef

define f_BINSRCS
endef

define f_ALLSRCS
endef

define LIBRULES
$($(1)_DIR)/lib/lib$(2).a: $(call f_SRC2O, $(call f_LIBSRCS,$(1),$(2)))
	mkdir -p $($(1)_DIR)/lib && \
	$(AR) $(ARFLAGS) $($(1)_DIR)/lib/lib$(2).a $(call f_SRC2O, $(call f_LIBSRCS,$(1),$(2)))

endef

define PROJRULES

$(call f_ANTLROPS,$(1)) &: $(call f_ANTLRINP,$(1))
	$(ANTLR) -o $($(1)_DIR)/src $(call f_ANTLRINP,$(1))

$(foreach l,$($(1)_LIBS),$(call LIBRULES,$(1),$(l)))

endef

#$(1)_DFILES		=	$(subst .cpp,.d,$(call f_ALLSRCS,$(1)))
#-include $$($(1)_DFILES)
#	@echo building $($(1)_DIR)/lib/lib$(2).a from $(call f_LIBSRCS,$(1),$(2))

# Convention:
# For BINS, binary name has a corresponding utils/<bin>.cpp program, unless <BIN>_SRC is defined
# If a project has a single LIB, build from src/*.cpp
# If a project has multiple LIBS, for each source there is corresponding src/<lib>.c
# If a project has no LIBS, use all sources for the BIN
# We use all include directories for compilation and all libs for linking, to keep it simple

all: $(LIBS)

$(foreach p, $(PROJECTS), $(eval $(call PROJRULES,$(p))))
